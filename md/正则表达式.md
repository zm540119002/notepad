# 零宽断言

## 基本概念

```
零宽断言正如它的名字一样，是一种零宽度的匹配，它匹配到的内容不会保存到匹配结果中去，最终匹配结果只是一个位置而已。
作用是给指定位置添加一个限定条件，用来规定此位置之前或者之后的字符必须满足限定条件才能使正则中的字表达式匹配成功。
注意:
	这里所说的子表达式并非只有用小括号括起来的表达式，而是正则表达式中的任意匹配单元。
	javascript只支持零宽先行断言，而零宽先行断言又可以分为正向零宽先行断言，和负向零宽先行断言。
```

```
零宽度正预测先行断言（正向肯定预查）：
	(?=exp) 	断言自身出现的位置的后面能匹配表达式exp
零宽度正回顾后发断言（正向否定预查）：
    (?<=exp)	断言自身出现的位置的前面能匹配表达式exp
零宽度负预测先行断言（反向肯定预查）：
    (?!exp) 	断言此位置的后面不能匹配表达式exp
零宽度负回顾后发断言（反向否定预查）：
    (?<!exp) 	断言此位置的前面不能匹配表达式exp
```

## 重复的元字符 —— \num

```
/num （num 表示一个正整数）

num 是一个数字，表示的是正则表达式中第 num 个可被捕获的 （）
这个可捕获的小括号位置是什么，\num 处出现一份一模一样的内容

示例：
let reg = /^(abc|def)\d+\1$/
console.log(reg.test("abc123abc"), reg.test('abc123def')) // true false

reg = /^([abcd])\d+([abcd])\d+\1\2$/
console.log(reg.test('a123b123ab')) // true

reg = /^(?:[abcd])\d+([abcd])\d+\1$/
console.log(reg.test('a123b123a'), reg.test('a123b123b')) // false true
```

# 复杂正则案例

## 任意连续5位不允许相同

```
1、一共17位只包含数字和大写字母
2、不包含英文字母“I”、“O”、“Q”
3、第13到17位为数字
3、任意连续5位不允许相同
答案：
	如果是不允许连续5位的字符都相同：
		^(?!.*(.)\1{4})[\dA-HJ-NPR-Z]{12}\d{5}$
	如果是不允许相隔5位之内有相同的字符：
		^(?!.*(.).{0,3}\1)[\dA-Z^IOQ]{12}\d{5}$
```

## 不允许有连续三位重复

```
/(\w)*(\w)\2{2}(\w)*/g
这个正则的意思就是任意的字母或数字或下划线（捕获为组1）
0次到多次跟着一个任意的字母或数字或下划线（捕获为组2）
紧跟着“\2{2}”是指反向捕获 组2（就是这里的内容要和组2一样的并且出现2次，所以就等于三个重复的）
后面跟着一个任意的字母或数字或下划线0次到多次
```

## 正则表达式去除连续重复的字符

```
如下字符串：
	abcdeeeddsssddaacc,,,bbbbbbHelllllllowwwworrrrlllld
修改为：
	abcdeddsddaacc,bbHellloworld
	
即：相同的字符串最多出现3次
	preg_replace('/(.*)\1{2,}/', '$1', $s)

先查询出所有重复3次以上的字符串
    (.*):所有字符串分组
    \1:取出每组的第一个字符
    {2,}:第一个字符再重复出现2次或以上
    $1:替换为(.*)括号里的内容，这个是一个字符串
```

## 其他

```
匹配 111 型 (\d)\1{2}
匹配  1122 型  (\d)\1{1}(\d)\2{1}
匹配 123 型  ((?:0(?=1)|1(?=2)|2(?=3)|3(?=4)|4(?=5)|5(?=6)|6(?=7)|7(?=8)|8(?=9)|9(?=0)){2}\d)
匹配数字型 1212 类型  ((?:0(?=1)|1(?=2)|2(?=3)|3(?=4)|4(?=5)|5(?=6)|6(?=7)|7(?=8)|8(?=9)|9(?=0)){1}\d)\1{1}
```

